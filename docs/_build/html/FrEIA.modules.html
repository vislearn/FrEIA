
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FrEIA.modules package &#8212; FrEIA v0.2 documentation</title>
    
  <link rel="stylesheet" href="_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    
  <link rel="preload" as="script" href="_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="FrEIA.framework package" href="FrEIA.framework.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="index.html">
    
      <p class="title">FrEIA</p>
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="FrEIA.framework.html">FrEIA.framework package</a>
        </li>
        
        <li class="nav-item active">
            <a class="nav-link" href="">FrEIA.modules package</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
          
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#abstract-template" class="nav-link">Abstract template</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#coupling-blocks" class="nav-link">Coupling blocks</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#reshaping" class="nav-link">Reshaping</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#graph-topology" class="nav-link">Graph topology</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#other-learned-transforms" class="nav-link">Other learned transforms</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#fixed-non-learned-transforms" class="nav-link">Fixed (non-learned) transforms</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#approximately-or-semi-invertible-transforms" class="nav-link">Approximately- or semi-invertible transforms</a>
        </li>
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="module-FrEIA.modules">
<span id="freia-modules-package"></span><h1>FrEIA.modules package<a class="headerlink" href="#module-FrEIA.modules" title="Permalink to this headline">¶</a></h1>
<p>Subclasses of torch.nn.Module, that are reversible and can be used in the
nodes of the GraphINN class. The only additional things that are
needed compared to the base class is an &#64;staticmethod otuput_dims, and the
‘rev’-argument of the forward-method.</p>
<p>Abstract template:</p>
<ul class="simple">
<li><p>InvertibleModule</p></li>
</ul>
<p>Coupling blocks:</p>
<ul class="simple">
<li><p>AllInOneBlock</p></li>
<li><p>NICECouplingBlock</p></li>
<li><p>RNVPCouplingBlock</p></li>
<li><p>GLOWCouplingBlock</p></li>
<li><p>GINCouplingBlock</p></li>
<li><p>AffineCouplingOneSided</p></li>
<li><p>ConditionalAffineTransform</p></li>
</ul>
<p>Reshaping:</p>
<ul class="simple">
<li><p>IRevNetDownsampling</p></li>
<li><p>IRevNetUpsampling</p></li>
<li><p>HaarDownsampling</p></li>
<li><p>HaarUpsampling</p></li>
<li><p>Flatten</p></li>
<li><p>Reshape</p></li>
</ul>
<p>Graph topology:</p>
<ul class="simple">
<li><p>Split</p></li>
<li><p>Concat</p></li>
</ul>
<p>Other learned transforms:</p>
<ul class="simple">
<li><p>ActNorm</p></li>
<li><p>IResNetLayer</p></li>
<li><p>InvAutoAct</p></li>
<li><p>InvAutoActFixed</p></li>
<li><p>InvAutoActTwoSided</p></li>
<li><p>InvAutoConv2D</p></li>
<li><p>InvAutoFC</p></li>
<li><p>LearnedElementwiseScaling</p></li>
<li><p>OrthogonalTransform</p></li>
<li><p>HouseholderPerm</p></li>
</ul>
<p>Fixed (non-learned) transforms:</p>
<ul class="simple">
<li><p>PermuteRandom</p></li>
<li><p>FixedLinearTransform</p></li>
<li><p>Fixed1x1Conv</p></li>
</ul>
<div class="section" id="abstract-template">
<h2>Abstract template<a class="headerlink" href="#abstract-template" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.InvertibleModule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">InvertibleModule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/base.html#InvertibleModule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvertibleModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all invertible modules in FrEIA.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">module</span></code>, an instance of some InvertibleModule.
This <code class="docutils literal notranslate"><span class="pre">module</span></code> shall be invertible in its input dimensions,
so that the input can be recovered by applying the module
in backwards mode (<code class="docutils literal notranslate"><span class="pre">rev=True</span></code>), not to be confused with
<code class="docutils literal notranslate"><span class="pre">pytorch.backward()</span></code> which computes the gradient of an operation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">DIM_COUNT</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">CONDITION_DIM</span><span class="p">)</span>

<span class="c1"># Forward mode</span>
<span class="n">z</span><span class="p">,</span> <span class="n">jac</span> <span class="o">=</span> <span class="n">module</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">jac</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Backward mode</span>
<span class="n">x_rev</span><span class="p">,</span> <span class="n">jac_rev</span> <span class="o">=</span> <span class="n">module</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">rev</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">module</span></code> returns <span class="math notranslate nohighlight">\(\log \det J = \log \left| \det \frac{\partial f}{\partial x} \right|\)</span>
of the operation in forward mode, and
<span class="math notranslate nohighlight">\(-\log | \det J | = \log \left| \det \frac{\partial f^{-1}}{\partial z} \right| = -\log \left| \det \frac{\partial f}{\partial x} \right|\)</span>
in backward mode (<code class="docutils literal notranslate"><span class="pre">rev=True</span></code>).</p>
<p>Then, <code class="docutils literal notranslate"><span class="pre">torch.allclose(x,</span> <span class="pre">x_rev)</span> <span class="pre">==</span> <span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">torch.allclose(jac,</span> <span class="pre">-jac_rev)</span> <span class="pre">==</span> <span class="pre">True</span></code>.</p>
<dl class="py method">
<dt id="FrEIA.modules.InvertibleModule.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/base.html#InvertibleModule.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvertibleModule.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims_in</strong> – list of tuples specifying the shape of the inputs to this
operator: <code class="docutils literal notranslate"><span class="pre">dims_in</span> <span class="pre">=</span> <span class="pre">[shape_x_0,</span> <span class="pre">shape_x_1,</span> <span class="pre">...]</span></code></p></li>
<li><p><strong>dims_c</strong> – list of tuples specifying the shape of the conditions to
this operator.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.InvertibleModule.forward">
<code class="sig-name descname"><span class="pre">forward</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_or_z</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rev</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span> </span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span><a class="reference internal" href="_modules/FrEIA/modules/base.html#InvertibleModule.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvertibleModule.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a forward (default, <code class="docutils literal notranslate"><span class="pre">rev=False</span></code>) or backward pass (<code class="docutils literal notranslate"><span class="pre">rev=True</span></code>)
through this module/operator.</p>
<p><strong>Note to implementers:</strong></p>
<ul>
<li><p>Subclasses MUST return a Jacobian when <code class="docutils literal notranslate"><span class="pre">jac=True</span></code>, but CAN return a
valid Jacobian when <code class="docutils literal notranslate"><span class="pre">jac=False</span></code> (not punished). The latter is only recommended
if the computation of the Jacobian is trivial.</p></li>
<li><p>Subclasses MUST follow the convention that the returned Jacobian be
consistent with the evaluation direction. Let’s make this more precise:
Let <span class="math notranslate nohighlight">\(f\)</span> be the function that the subclass represents. Then:</p>
<div class="math notranslate nohighlight">
\[\begin{split}J &amp;= \log \det \frac{\partial f}{\partial x} \\
-J &amp;= \log \det \frac{\partial f^{-1}}{\partial z}.\end{split}\]</div>
<p>Any subclass MUST return <span class="math notranslate nohighlight">\(J\)</span> for forward evaluation (<code class="docutils literal notranslate"><span class="pre">rev=False</span></code>),
and <span class="math notranslate nohighlight">\(-J\)</span> for backward evaluation (<code class="docutils literal notranslate"><span class="pre">rev=True</span></code>).</p>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_or_z</strong> – input data (array-like of one or more tensors)</p></li>
<li><p><strong>c</strong> – conditioning data (array-like of none or more tensors)</p></li>
<li><p><strong>rev</strong> – perform backward pass</p></li>
<li><p><strong>jac</strong> – return Jacobian associated to the direction</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.InvertibleModule.log_jacobian">
<code class="sig-name descname"><span class="pre">log_jacobian</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/base.html#InvertibleModule.log_jacobian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvertibleModule.log_jacobian" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is deprecated, and does nothing except raise a warning.</p>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.InvertibleModule.output_dims">
<code class="sig-name descname"><span class="pre">output_dims</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_dims</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> &#x2192; <span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><a class="reference internal" href="_modules/FrEIA/modules/base.html#InvertibleModule.output_dims"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvertibleModule.output_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for shape inference during construction of the graph. MUST be
implemented for each subclass of <code class="docutils literal notranslate"><span class="pre">InvertibleModule</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_dims</strong> – A list with one entry for each input to the module.
Even if the module only has one input, must be a list with one
entry. Each entry is a tuple giving the shape of that input,
excluding the batch dimension. For example for a module with one
input, which receives a 32x32 pixel RGB image, <code class="docutils literal notranslate"><span class="pre">input_dims</span></code> would
be <code class="docutils literal notranslate"><span class="pre">[(3,</span> <span class="pre">32,</span> <span class="pre">32)]</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list structured in the same way as <code class="docutils literal notranslate"><span class="pre">input_dims</span></code>. Each entry
represents one output of the module, and the entry is a tuple giving
the shape of that output. For example if the module splits the image
into a right and a left half, the return value should be
<code class="docutils literal notranslate"><span class="pre">[(3,</span> <span class="pre">16,</span> <span class="pre">32),</span> <span class="pre">(3,</span> <span class="pre">16,</span> <span class="pre">32)]</span></code>. It is up to the implementor of the
subclass to ensure that the total number of elements in all inputs
and all outputs is consistent.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="coupling-blocks">
<h2>Coupling blocks<a class="headerlink" href="#coupling-blocks" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.AllInOneBlock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">AllInOneBlock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_clamping</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gin_block</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_affine_init</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_affine_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'SOFTPLUS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute_soft</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learned_householder_permutation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_permutation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/all_in_one_block.html#AllInOneBlock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.AllInOneBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Module combining the most common operations in a normalizing flow or similar model.</p>
<p>It combines affine coupling, permutation, and global affine transformation
(‘ActNorm’). It can also be used as GIN coupling block, perform learned
householder permutations, and use an inverted pre-permutation. The affine
transformation includes a soft clamping mechanism, first used in Real-NVP.
The block as a whole performs the following computation:</p>
<div class="math notranslate nohighlight">
\[y = V\,R \; \Psi(s_\mathrm{global}) \odot \mathrm{Coupling}\Big(R^{-1} V^{-1} x\Big)+ t_\mathrm{global}\]</div>
<ul>
<li><p>The inverse pre-permutation of x (i.e. <span class="math notranslate nohighlight">\(R^{-1} V^{-1}\)</span>) is optional (see
<code class="docutils literal notranslate"><span class="pre">reverse_permutation</span></code> below).</p></li>
<li><p>The learned householder reflection matrix
<span class="math notranslate nohighlight">\(V\)</span> is also optional all together (see <code class="docutils literal notranslate"><span class="pre">learned_householder_permutation</span></code>
below).</p></li>
<li><p>For the coupling, the input is split into <span class="math notranslate nohighlight">\(x_1, x_2\)</span> along
the channel dimension. Then the output of the coupling operation is the
two halves <span class="math notranslate nohighlight">\(u = \mathrm{concat}(u_1, u_2)\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}u_1 &amp;= x_1 \odot \exp \Big( \alpha \; \mathrm{tanh}\big( s(x_2) \big)\Big) + t(x_2) \\
u_2 &amp;= x_2\end{split}\]</div>
<p>Because <span class="math notranslate nohighlight">\(\mathrm{tanh}(s) \in [-1, 1]\)</span>, this clamping mechanism prevents
exploding values in the exponential. The hyperparameter <span class="math notranslate nohighlight">\(\alpha\)</span> can be adjusted.</p>
</li>
</ul>
<dl class="py method">
<dt id="FrEIA.modules.AllInOneBlock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affine_clamping</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gin_block</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_affine_init</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">global_affine_type</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">str</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'SOFTPLUS'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permute_soft</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learned_householder_permutation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_permutation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/all_in_one_block.html#AllInOneBlock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.AllInOneBlock.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subnet_constructor</strong> – class or callable <code class="docutils literal notranslate"><span class="pre">f</span></code>, called as <code class="docutils literal notranslate"><span class="pre">f(channels_in,</span> <span class="pre">channels_out)</span></code> and
should return a torch.nn.Module. Predicts coupling coefficients <span class="math notranslate nohighlight">\(s, t\)</span>.</p></li>
<li><p><strong>affine_clamping</strong> – clamp the output of the multiplicative coefficients before
exponentiation to +/- <code class="docutils literal notranslate"><span class="pre">affine_clamping</span></code> (see <span class="math notranslate nohighlight">\(\alpha\)</span> above).</p></li>
<li><p><strong>gin_block</strong> – Turn the block into a GIN block from Sorrenson et al, 2019.
Makes it so that the coupling operations as a whole is volume preserving.</p></li>
<li><p><strong>global_affine_init</strong> – Initial value for the global affine scaling <span class="math notranslate nohighlight">\(s_\mathrm{global}\)</span>.</p></li>
<li><p><strong>global_affine_init</strong> – <code class="docutils literal notranslate"><span class="pre">'SIGMOID'</span></code>, <code class="docutils literal notranslate"><span class="pre">'SOFTPLUS'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'EXP'</span></code>. Defines the activation to be used
on the beta for the global affine scaling (<span class="math notranslate nohighlight">\(\Psi\)</span> above).</p></li>
<li><p><strong>permute_soft</strong> – bool, whether to sample the permutation matrix <span class="math notranslate nohighlight">\(R\)</span> from <span class="math notranslate nohighlight">\(SO(N)\)</span>,
or to use hard permutations instead. Note, <code class="docutils literal notranslate"><span class="pre">permute_soft=True</span></code> is very slow
when working with &gt;512 dimensions.</p></li>
<li><p><strong>learned_householder_permutation</strong> – Int, if &gt;0, turn on the matrix <span class="math notranslate nohighlight">\(V\)</span> above, that represents
multiple learned householder reflections. Slow if large number.
Dubious whether it actually helps network performance.</p></li>
<li><p><strong>reverse_permutation</strong> – Reverse the permutation before the block, as introduced by Putzky
et al, 2019. Turns on the <span class="math notranslate nohighlight">\(R^{-1} V^{-1}\)</span> pre-multiplication above.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.NICECouplingBlock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">NICECouplingBlock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#NICECouplingBlock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.NICECouplingBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling Block following the NICE (Dinh et al, 2015) design.
The inputs are split in two halves. For 2D, 3D, 4D inputs, the split is
performed along the channel dimension. Then, residual coefficients are
predicted by two subnetworks that are added to each half in turn.</p>
<dl class="py method">
<dt id="FrEIA.modules.NICECouplingBlock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#NICECouplingBlock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.NICECouplingBlock.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>subnet_constructor</strong> – Callable function, class, or factory object, with signature
constructor(dims_in, dims_out). The result should be a torch
nn.Module, that takes dims_in input channels, and dims_out output
channels. See tutorial for examples.
Two of these subnetworks will be initialized inside the block.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.RNVPCouplingBlock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">RNVPCouplingBlock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#RNVPCouplingBlock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.RNVPCouplingBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling Block following the RealNVP design (Dinh et al, 2017) with some
minor differences. The inputs are split in two halves. For 2D, 3D, 4D
inputs, the split is performed along the channel dimension. For
checkerboard-splitting, prepend an i_RevNet_downsampling module. Two affine
coupling operations are performed in turn on both halves of the input.</p>
<dl class="py method">
<dt id="FrEIA.modules.RNVPCouplingBlock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#RNVPCouplingBlock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.RNVPCouplingBlock.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subnet_constructor</strong> – function or class, with signature
constructor(dims_in, dims_out).  The result should be a torch
nn.Module, that takes dims_in input channels, and dims_out output
channels. See tutorial for examples. Four of these subnetworks will be
initialized in the block.</p></li>
<li><p><strong>clamp</strong> – Soft clamping for the multiplicative component. The
amplification or attenuation of each input dimension can be at most
exp(±clamp).</p></li>
<li><p><strong>clamp_activation</strong> – Function to perform the clamping. String values
“ATAN”, “TANH”, and “SIGMOID” are recognized, or a function of
object can be passed. TANH behaves like the original realNVP paper.
A custom function should take tensors and map -inf to -1 and +inf to +1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.GLOWCouplingBlock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">GLOWCouplingBlock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#GLOWCouplingBlock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GLOWCouplingBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling Block following the GLOW design. Note, this is only the coupling
part itself, and does not include ActNorm, invertible 1x1 convolutions, etc.
See AllInOneBlock for a block combining these functions at once.
The only difference to the RNVPCouplingBlock coupling blocks
is that it uses a single subnetwork to jointly predict [s_i, t_i], instead of two separate
subnetworks. This reduces computational cost and speeds up learning.</p>
<dl class="py method">
<dt id="FrEIA.modules.GLOWCouplingBlock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#GLOWCouplingBlock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GLOWCouplingBlock.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subnet_constructor</strong> – function or class, with signature
constructor(dims_in, dims_out).  The result should be a torch
nn.Module, that takes dims_in input channels, and dims_out output
channels. See tutorial for examples. Two of these subnetworks will be
initialized in the block.</p></li>
<li><p><strong>clamp</strong> – Soft clamping for the multiplicative component. The
amplification or attenuation of each input dimension can be at most
exp(±clamp).</p></li>
<li><p><strong>clamp_activation</strong> – Function to perform the clamping. String values
“ATAN”, “TANH”, and “SIGMOID” are recognized, or a function of
object can be passed. TANH behaves like the original realNVP paper.
A custom function should take tensors and map -inf to -1 and +inf to +1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.GINCouplingBlock">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">GINCouplingBlock</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#GINCouplingBlock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GINCouplingBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Coupling Block following the GIN design. The difference from
GLOWCouplingBlock (and other affine coupling blocks) is that the Jacobian
determinant is constrained to be 1.  This constrains the block to be
volume-preserving. Volume preservation is achieved by subtracting the mean
of the output of the s subnetwork from itself.  While volume preserving, GIN
is still more powerful than NICE, as GIN is not volume preserving within
each dimension.
Note: this implementation differs slightly from the originally published
implementation, which scales the final component of the s subnetwork so the
sum of the outputs of s is zero. There was no difference found between the
implementations in practice, but subtracting the mean guarantees that all
outputs of s are at most ±exp(clamp), which might be more stable in certain
cases.</p>
<dl class="py method">
<dt id="FrEIA.modules.GINCouplingBlock.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#GINCouplingBlock.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GINCouplingBlock.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subnet_constructor</strong> – function or class, with signature
constructor(dims_in, dims_out).  The result should be a torch
nn.Module, that takes dims_in input channels, and dims_out output
channels. See tutorial for examples. Two of these subnetworks will be
initialized in the block.</p></li>
<li><p><strong>clamp</strong> – Soft clamping for the multiplicative component. The
amplification or attenuation of each input dimension can be at most
exp(±clamp).</p></li>
<li><p><strong>clamp_activation</strong> – Function to perform the clamping. String values
“ATAN”, “TANH”, and “SIGMOID” are recognized, or a function of
object can be passed. TANH behaves like the original realNVP paper.
A custom function should take tensors and map -inf to -1 and +inf to +1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.AffineCouplingOneSided">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">AffineCouplingOneSided</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#AffineCouplingOneSided"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.AffineCouplingOneSided" title="Permalink to this definition">¶</a></dt>
<dd><p>Half of a coupling block following the GLOWCouplingBlock design.  This
means only one affine transformation on half the inputs.  In the case where
random permutations or orthogonal transforms are used after every block,
this is not a restriction and simplifies the design.</p>
<dl class="py method">
<dt id="FrEIA.modules.AffineCouplingOneSided.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#AffineCouplingOneSided.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.AffineCouplingOneSided.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subnet_constructor</strong> – function or class, with signature
constructor(dims_in, dims_out).  The result should be a torch
nn.Module, that takes dims_in input channels, and dims_out output
channels. See tutorial for examples. One subnetwork will be
initialized in the block.</p></li>
<li><p><strong>clamp</strong> – Soft clamping for the multiplicative component. The
amplification or attenuation of each input dimension can be at most
exp(±clamp).</p></li>
<li><p><strong>clamp_activation</strong> – Function to perform the clamping. String values
“ATAN”, “TANH”, and “SIGMOID” are recognized, or a function of
object can be passed. TANH behaves like the original realNVP paper.
A custom function should take tensors and map -inf to -1 and +inf to +1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.ConditionalAffineTransform">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">ConditionalAffineTransform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#ConditionalAffineTransform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.ConditionalAffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to the conditioning layers from SPADE (Park et al, 2019): Perform
an affine transformation on the whole input, where the affine coefficients
are predicted from only the condition.</p>
<dl class="py method">
<dt id="FrEIA.modules.ConditionalAffineTransform.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subnet_constructor</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp_activation</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span> </span><span class="pre">Callable</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">'ATAN'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/coupling_layers.html#ConditionalAffineTransform.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.ConditionalAffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>subnet_constructor</strong> – function or class, with signature
constructor(dims_in, dims_out).  The result should be a torch
nn.Module, that takes dims_in input channels, and dims_out output
channels. See tutorial for examples. One subnetwork will be
initialized in the block.</p></li>
<li><p><strong>clamp</strong> – Soft clamping for the multiplicative component. The
amplification or attenuation of each input dimension can be at most
exp(±clamp).</p></li>
<li><p><strong>clamp_activation</strong> – Function to perform the clamping. String values
“ATAN”, “TANH”, and “SIGMOID” are recognized, or a function of
object can be passed. TANH behaves like the original realNVP paper.
A custom function should take tensors and map -inf to -1 and +inf to +1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="reshaping">
<h2>Reshaping<a class="headerlink" href="#reshaping" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.IRevNetDownsampling">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">IRevNetDownsampling</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy_backend</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#IRevNetDownsampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IRevNetDownsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>The invertible spatial downsampling used in i-RevNet.
Each group of four neighboring pixels is reordered into one pixel with four times
the channels in a checkerboard-like pattern. See i-RevNet, Jacobsen 2018 et al.</p>
<dl class="py method">
<dt id="FrEIA.modules.IRevNetDownsampling.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy_backend</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#IRevNetDownsampling.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IRevNetDownsampling.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See docstring of base class (FrEIA.modules.InvertibleModule) for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>legacy_backend</strong> – <p>If True, uses the splitting and concatenating method,
adapted from
github.com/jhjacobsen/pytorch-i-revnet/blob/master/models/model_utils.py
for the use in FrEIA. Is usually slower on GPU.
If False, uses a 2d strided convolution with a kernel representing
the downsampling. Note that the ordering of the output channels
will be different. If pixels in each patch in channel 1
are <code class="docutils literal notranslate"><span class="pre">a1,</span> <span class="pre">b1,...</span></code>, and in channel 2 are <code class="docutils literal notranslate"><span class="pre">a2,</span> <span class="pre">b2,...</span></code>
Then the output channels will be the following:</p>
<p><code class="docutils literal notranslate"><span class="pre">legacy_backend=True:</span> <span class="pre">a1,</span> <span class="pre">a2,</span> <span class="pre">...,</span> <span class="pre">b1,</span> <span class="pre">b2,</span> <span class="pre">...,</span> <span class="pre">c1,</span> <span class="pre">c2,</span> <span class="pre">...</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">legacy_backend=False:</span> <span class="pre">a1,</span> <span class="pre">b1,</span> <span class="pre">...,</span> <span class="pre">a2,</span> <span class="pre">b2,</span> <span class="pre">...,</span> <span class="pre">a3,</span> <span class="pre">b3,</span> <span class="pre">...</span></code></p>
<p>(see also order_by_wavelet in module HaarDownsampling)
Generally this difference is completely irrelevant,
unless a certaint subset of pixels or channels is supposed to be
split off or extracted.</p>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.IRevNetUpsampling">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">IRevNetUpsampling</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy_backend</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#IRevNetUpsampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IRevNetUpsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverted operation of IRevNetDownsampling (see that docstring for details).</p>
<dl class="py method">
<dt id="FrEIA.modules.IRevNetUpsampling.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legacy_backend</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#IRevNetUpsampling.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IRevNetUpsampling.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See docstring of base class (FrEIA.modules.InvertibleModule) for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>legacy_backend</strong> – <p>If True, uses the splitting and concatenating method,
adapted from
github.com/jhjacobsen/pytorch-i-revnet/blob/master/models/model_utils.py
for the use in FrEIA. Is usually slower on GPU.
If False, uses a 2d strided transposed convolution with a representing
the downsampling. Note that the expected ordering of the input channels
will be different. If pixels in each output patch in channel 1
are <code class="docutils literal notranslate"><span class="pre">a1,</span> <span class="pre">b1,...</span></code>, and in channel 2 are <code class="docutils literal notranslate"><span class="pre">a2,</span> <span class="pre">b2,...</span></code>
Then the expected input channels are be the following:</p>
<p><code class="docutils literal notranslate"><span class="pre">legacy_backend=True:</span> <span class="pre">a1,</span> <span class="pre">a2,</span> <span class="pre">...,</span> <span class="pre">b1,</span> <span class="pre">b2,</span> <span class="pre">...,</span> <span class="pre">c1,</span> <span class="pre">c2,</span> <span class="pre">...</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">legacy_backend=False:</span> <span class="pre">a1,</span> <span class="pre">b1,</span> <span class="pre">...,</span> <span class="pre">a2,</span> <span class="pre">b2,</span> <span class="pre">...,</span> <span class="pre">a3,</span> <span class="pre">b3,</span> <span class="pre">...</span></code></p>
<p>(see also order_by_wavelet in module HaarDownsampling)
Generally this difference is completely irrelevant,
unless a certaint subset of pixels or channels is supposed to be
split off or extracted.</p>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.HaarDownsampling">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">HaarDownsampling</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_by_wavelet</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rebalance</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#HaarDownsampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.HaarDownsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Haar wavelets to split each channel into 4 channels, with half the
width and height dimensions.</p>
<dl class="py method">
<dt id="FrEIA.modules.HaarDownsampling.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_by_wavelet</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rebalance</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#HaarDownsampling.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.HaarDownsampling.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See docstring of base class (FrEIA.modules.InvertibleModule) for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order_by_wavelet</strong> – <p>Whether to group the output by original channels or
by wavelet. I.e. if the average, vertical, horizontal and diagonal
wavelets for channel 1 are <code class="docutils literal notranslate"><span class="pre">a1,</span> <span class="pre">v1,</span> <span class="pre">h1,</span> <span class="pre">d1</span></code>, those for channel 2 are
<code class="docutils literal notranslate"><span class="pre">a2,</span> <span class="pre">v2,</span> <span class="pre">h2,</span> <span class="pre">d2</span></code>, etc, then the output channels will be structured as
follows:</p>
<p>set to <code class="docutils literal notranslate"><span class="pre">True:</span> <span class="pre">a1,</span> <span class="pre">a2,</span> <span class="pre">...,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">...,</span> <span class="pre">h1,</span> <span class="pre">h2,</span> <span class="pre">...,</span> <span class="pre">d1,</span> <span class="pre">d2,</span> <span class="pre">...</span></code></p>
<p>set to <code class="docutils literal notranslate"><span class="pre">False:</span> <span class="pre">a1,</span> <span class="pre">v1,</span> <span class="pre">h1,</span> <span class="pre">d1,</span> <span class="pre">a2,</span> <span class="pre">v2,</span> <span class="pre">h2,</span> <span class="pre">d2,</span> <span class="pre">...</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">True</span></code> option is slightly slower to compute than the <code class="docutils literal notranslate"><span class="pre">False</span></code> option.
The option is useful if e.g. the average channels should be split
off by a FrEIA.modules.Split. Then, setting <code class="docutils literal notranslate"><span class="pre">order_by_wavelet=True</span></code>
allows to split off the first quarter of channels to isolate the
average wavelets only.</p>
</p></li>
<li><p><strong>rebalance</strong> – Must be !=0. There exist different conventions how to define
the Haar wavelets. The wavelet components in the forward direction
are multiplied with this factor, and those in the inverse direction
are adjusted accordingly, so that the module as a whole is
invertible.  Stability of the network may be increased for rebalance
&lt; 1 (e.g. 0.5).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.HaarUpsampling">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">HaarUpsampling</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_by_wavelet</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rebalance</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#HaarUpsampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.HaarUpsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverted operation of HaarDownsampling (see that docstring for details).</p>
<dl class="py method">
<dt id="FrEIA.modules.HaarUpsampling.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_by_wavelet</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rebalance</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#HaarUpsampling.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.HaarUpsampling.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See docstring of base class (FrEIA.modules.InvertibleModule) for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order_by_wavelet</strong> – <p>Expected grouping of the input channels by wavelet or
by output channel. I.e. if the average, vertical, horizontal and diagonal
wavelets for channel 1 are <code class="docutils literal notranslate"><span class="pre">a1,</span> <span class="pre">v1,</span> <span class="pre">h1,</span> <span class="pre">d1</span></code>, those for channel 2 are
<code class="docutils literal notranslate"><span class="pre">a2,</span> <span class="pre">v2,</span> <span class="pre">h2,</span> <span class="pre">d2</span></code>, etc, then the input channels are taken as follows:</p>
<p>set to <code class="docutils literal notranslate"><span class="pre">True:</span> <span class="pre">a1,</span> <span class="pre">a2,</span> <span class="pre">...,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">...,</span> <span class="pre">h1,</span> <span class="pre">h2,</span> <span class="pre">...,</span> <span class="pre">d1,</span> <span class="pre">d2,</span> <span class="pre">...</span></code></p>
<p>set to <code class="docutils literal notranslate"><span class="pre">False:</span> <span class="pre">a1,</span> <span class="pre">v1,</span> <span class="pre">h1,</span> <span class="pre">d1,</span> <span class="pre">a2,</span> <span class="pre">v2,</span> <span class="pre">h2,</span> <span class="pre">d2,</span> <span class="pre">...</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">True</span></code> option is slightly slower to compute than the <code class="docutils literal notranslate"><span class="pre">False</span></code> option.
The option is useful if e.g. the input has been concatentated from average
channels and the higher-frequency channels. Then, setting
<code class="docutils literal notranslate"><span class="pre">order_by_wavelet=True</span></code> allows to split off the first quarter of
channels to isolate the average wavelets only.</p>
</p></li>
<li><p><strong>rebalance</strong> – Must be !=0. There exist different conventions how to define
the Haar wavelets. The wavelet components in the forward direction
are multiplied with this factor, and those in the inverse direction
are adjusted accordingly, so that the module as a whole is
invertible.  Stability of the network may be increased for rebalance
&lt; 1 (e.g. 0.5).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.Flatten">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">Flatten</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#Flatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flattens N-D tensors into 1-D tensors.</p>
<dl class="py method">
<dt id="FrEIA.modules.Flatten.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#Flatten.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Flatten.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See docstring of base class (FrEIA.modules.InvertibleModule).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.Reshape">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">Reshape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dims</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#Reshape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshapes N-D tensors into target dim tensors. Note that the reshape resulting from
e.g. (3, 32, 32) -&gt; (12, 16, 16) will not necessarily be spatially sensible.
See <code class="docutils literal notranslate"><span class="pre">IRevNetDownsampling</span></code>, <code class="docutils literal notranslate"><span class="pre">IRevNetUpsampling</span></code>, <code class="docutils literal notranslate"><span class="pre">HaarDownsampling</span></code>,
<code class="docutils literal notranslate"><span class="pre">HaarUpsampling</span></code> for spatially meaningful reshaping operations.</p>
<dl class="py method">
<dt id="FrEIA.modules.Reshape.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dims</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Iterable</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/reshapes.html#Reshape.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Reshape.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See docstring of base class (FrEIA.modules.InvertibleModule) for more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>output_dims</strong> – The shape the reshaped output is supposed to have (not
including batch dimension)</p></li>
<li><p><strong>target_dim</strong> – Deprecated name for output_dims</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="graph-topology">
<h2>Graph topology<a class="headerlink" href="#graph-topology" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.Split">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">Split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section_sizes</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sections</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/graph_topology.html#Split"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Split" title="Permalink to this definition">¶</a></dt>
<dd><p>Invertible split operation.</p>
<p>Splits the incoming tensor along the given dimension, and returns a list of
separate output tensors. The inverse is the corresponding merge operation.</p>
<dl class="py method">
<dt id="FrEIA.modules.Split.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">section_sizes</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_sections</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/graph_topology.html#Split.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Split.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inits the Split module with the attributes described above and
checks that split sizes and dimensionality are compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims_in</strong> – A list of tuples containing the non-batch dimensionality of all
incoming tensors. Handled automatically during compute graph setup.
Split only takes one input tensor.</p></li>
<li><p><strong>section_sizes</strong> – If set, takes precedence over <code class="docutils literal notranslate"><span class="pre">n_sections</span></code> and behaves like the
argument in torch.split(), except when a list of section sizes is given
that doesn’t add up to the size of <code class="docutils literal notranslate"><span class="pre">dim</span></code>, an additional split section is
created to take the slack. Defaults to None.</p></li>
<li><p><strong>n_sections</strong> – If <code class="docutils literal notranslate"><span class="pre">section_sizes</span></code> is None, the tensor is split into <code class="docutils literal notranslate"><span class="pre">n_sections</span></code>
parts of equal size or close to it. This mode behaves like
<code class="docutils literal notranslate"><span class="pre">numpy.array_split()</span></code>. Defaults to 2, i.e. splitting the data into two
equal halves.</p></li>
<li><p><strong>dim</strong> – Index of the dimension along which to split, not counting the batch
dimension. Defaults to 0, i.e. the channel dimension in structured data.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.Concat">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">Concat</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/graph_topology.html#Concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Invertible merge operation.</p>
<p>Concatenates a list of incoming tensors along a given dimension and passes
on the result. Inverse is the corresponding split operation.</p>
<dl class="py method">
<dt id="FrEIA.modules.Concat.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/graph_topology.html#Concat.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Concat.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inits the Concat module with the attributes described above and
checks that all dimensions are compatible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dims_in</strong> – A list of tuples containing the non-batch dimensionality of all
incoming tensors. Handled automatically during compute graph setup.
Dimensionality of incoming tensors must be identical, except in the
merge dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code>. Concat only makes sense with multiple input
tensors.</p></li>
<li><p><strong>dim</strong> – Index of the dimension along which to concatenate, not counting the
batch dimension. Defaults to 0, i.e. the channel dimension in structured
data.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="other-learned-transforms">
<h2>Other learned transforms<a class="headerlink" href="#other-learned-transforms" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.ActNorm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">ActNorm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/invertible_resnet.html#ActNorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.ActNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>A technique to achieve a stable initlization.</p>
<p>First introduced in Kingma et al 2018: <a class="reference external" href="https://arxiv.org/abs/1807.03039">https://arxiv.org/abs/1807.03039</a>
The module is similar to a traditional batch normalization layer, but the
data mean and standard deviation is only computed for the first batch of
data. To ensure invertibility, the mean and standard devation are kept
fixed from that point on.
Using ActNorm layers interspersed throughout an INN ensures that
intermediate outputs of the INN have standard deviation 1 and mean 0, so
that the training is stable at the start, avoiding exploding or zeroed
outputs.
Just as with standard batch normalization layers, ActNorm contains
additional channel-wise scaling and bias parameters.</p>
<dl class="py method">
<dt id="FrEIA.modules.ActNorm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/invertible_resnet.html#ActNorm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.ActNorm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>init_data</strong> – If <code class="docutils literal notranslate"><span class="pre">None</span></code>, use the first batch of data passed through this
module to initialize the mean and standard deviation.
If <code class="docutils literal notranslate"><span class="pre">torch.Tensor</span></code>, use this as data to initialize instead of the
first real batch.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.InvAutoAct">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">InvAutoAct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learnable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoAct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoAct" title="Permalink to this definition">¶</a></dt>
<dd><p>A nonlinear invertible activation analogous to Leaky ReLU, with
learned slopes.</p>
<p>The slope is symmetric between the positive and negative side, i.e.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x \geq 0 &amp;\implies g(x) = x \odot \exp(\alpha)\\x &lt; 0 &amp;\implies g(x) = x \oslash \exp(\alpha)\end{aligned}\end{align} \]</div>
<p>A separate slope is learned for each entry along the first
intput dimenison (after the batch dimenison). I.e. element-wise for
flattened inputs, channel-wise for image inputs, etc.</p>
<dl class="py method">
<dt id="FrEIA.modules.InvAutoAct.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slope_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learnable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoAct.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoAct.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slope_init</strong> – The initial value of the slope on the positive side.
Accounts for the exp-activation, i.e. <span class="math notranslate nohighlight">\(\exp(\alpha) =\)</span> <code class="docutils literal notranslate"><span class="pre">slope_init</span></code>.</p></li>
<li><p><strong>learnable</strong> – If False, the slopes are fixed at their initial value, and not learned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.InvAutoActTwoSided">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">InvAutoActTwoSided</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pos</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_neg</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learnable</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoActTwoSided"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoActTwoSided" title="Permalink to this definition">¶</a></dt>
<dd><p>A nonlinear invertible activation analogous to Leaky ReLU, with
learned slopes.</p>
<p>The slopes are learned separately for each entry along the first
intput dimenison (after the batch dimenison). I.e. element-wise for
flattened inputs, channel-wise for image inputs, etc.
Internally, the slopes are learned in log-space, to ensure they stay
strictly &gt; 0:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x \geq 0 &amp;\implies g(x) = x \odot \exp(\alpha_+)\\x &lt; 0 &amp;\implies g(x) = x \odot \exp(\alpha_-)\end{aligned}\end{align} \]</div>
<dl class="py method">
<dt id="FrEIA.modules.InvAutoActTwoSided.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pos</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_neg</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learnable</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoActTwoSided.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoActTwoSided.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>init_pos</strong> – The initial slope for the positive half of the activation. Must be &gt; 0.
Note that the initial value accounts for the exp-activation, meaning
<span class="math notranslate nohighlight">\(\exp(\alpha_+) =\)</span> <code class="docutils literal notranslate"><span class="pre">init_pos</span></code>.</p></li>
<li><p><strong>init_pos</strong> – The initial slope for the negative half of the activation. Must be &gt; 0.
The initial value accounts for the exp-activation the same as init_pos.</p></li>
<li><p><strong>learnable</strong> – If False, the slopes are fixed at their initial value, and not learned.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.LearnedElementwiseScaling">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">LearnedElementwiseScaling</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#LearnedElementwiseScaling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.LearnedElementwiseScaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale each element of the input by a learned, non-negative factor.
Unlike most other FrEIA modules, the scaling is not e.g. channel-wise for images,
but really scales each individual element.
To ensure positivity, the scaling is learned in log-space:</p>
<div class="math notranslate nohighlight">
\[g(x) = x \odot \exp(s)\]</div>
<dl class="py method">
<dt id="FrEIA.modules.LearnedElementwiseScaling.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#LearnedElementwiseScaling.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.LearnedElementwiseScaling.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>init_scale</strong> – The initial scaling value. It accounts for the exp-activation,
i.e. <span class="math notranslate nohighlight">\(\exp(s) =\)</span> <code class="docutils literal notranslate"><span class="pre">init_scale</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.OrthogonalTransform">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">OrthogonalTransform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correction_interval</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/orthogonal.html#OrthogonalTransform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.OrthogonalTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Learnable orthogonal matrix, with additional scaling and bias term.</p>
<p>The matrix is learned as a completely free weight matrix, and projected back
to the Stiefel manifold (set of all orthogonal matrices) in regular intervals.
With input x, the output z is computed as</p>
<div class="math notranslate nohighlight">
\[z = \Psi(s) \odot  Rx + b\]</div>
<p>R is the orthogonal matrix, b the bias, s the scaling, and <span class="math notranslate nohighlight">\(\Psi\)</span>
is a clamped scaling activation
<span class="math notranslate nohighlight">\(\Psi(\cdot) = \exp(\frac{2 \alpha}{\pi} \mathrm{atan}(\cdot))\)</span>.</p>
<dl class="py method">
<dt id="FrEIA.modules.OrthogonalTransform.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correction_interval</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clamp</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">float</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/orthogonal.html#OrthogonalTransform.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.OrthogonalTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>correction_interval</strong> – After this many gradient steps, the matrix is
projected back to the Stiefel manifold to make it perfectly orthogonal.</p></li>
<li><p><strong>clamp</strong> – clamps the log scaling for stability. Corresponds to
<span class="math notranslate nohighlight">\(alpha\)</span> above.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.HouseholderPerm">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">HouseholderPerm</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reflections</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/orthogonal.html#HouseholderPerm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.HouseholderPerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast product of a series of learned Householder matrices.
This implementation is based on work by Mathiesen et al, 2020:
<a class="reference external" href="https://invertibleworkshop.github.io/accepted_papers/pdfs/10.pdf">https://invertibleworkshop.github.io/accepted_papers/pdfs/10.pdf</a>
Only works for flattened 1D input tensors.</p>
<p>The module can be used in one of two ways:</p>
<ul class="simple">
<li><p>Without a condition, the reflection vectors that form the householder
matrices are learned as free parameters</p></li>
<li><p>Used as a conditional module, the condition conatins the reflection vectors.
The module does not have any learnable parameters in that case, but the
condition can be backpropagated (e.g. to predict the reflection vectors by
some other network). The condition must have the shape
<code class="docutils literal notranslate"><span class="pre">(input</span> <span class="pre">size,</span> <span class="pre">n_reflections)</span></code>.</p></li>
</ul>
<dl class="py method">
<dt id="FrEIA.modules.HouseholderPerm.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_reflections</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">int</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">bool</span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/orthogonal.html#HouseholderPerm.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.HouseholderPerm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_reflections</strong> – How many subsequent householder reflections to perform.
Each householder reflection is learned independently.
Must be <code class="docutils literal notranslate"><span class="pre">&gt;=</span> <span class="pre">2</span></code> due to implementation reasons.</p></li>
<li><p><strong>fixed</strong> – If true, the householder matrices are initialized randomly and
only computed once, and then kept fixed from there on.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="fixed-non-learned-transforms">
<h2>Fixed (non-learned) transforms<a class="headerlink" href="#fixed-non-learned-transforms" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.PermuteRandom">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">PermuteRandom</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/fixed_transforms.html#PermuteRandom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.PermuteRandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a random permutation, that stays fixed during training.
Permutes along the first (channel-) dimension for multi-dimenional tensors.</p>
<dl class="py method">
<dt id="FrEIA.modules.PermuteRandom.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/fixed_transforms.html#PermuteRandom.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.PermuteRandom.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class FrEIA.modules.InvertibleModule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seed</strong> – Int seed for the permutation (numpy is used for RNG). If seed is
None, do not reseed RNG.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.FixedLinearTransform">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">FixedLinearTransform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/fixed_transforms.html#FixedLinearTransform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.FixedLinearTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fixed linear transformation for 1D input tesors. The transformation is
<span class="math notranslate nohighlight">\(y = Mx + b\)</span>. With <em>d</em> input dimensions, <em>M</em> must be an invertible <em>d x d</em> tensor,
and <em>b</em> is an optional offset vector of length <em>d</em>.</p>
<dl class="py method">
<dt id="FrEIA.modules.FixedLinearTransform.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/fixed_transforms.html#FixedLinearTransform.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.FixedLinearTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class FrEIA.modules.InvertibleModule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> – Square, invertible matrix, with which each input is multiplied. Shape <code class="docutils literal notranslate"><span class="pre">(d,</span> <span class="pre">d)</span></code>.</p></li>
<li><p><strong>b</strong> – Optional vector which is added element-wise. Shape <code class="docutils literal notranslate"><span class="pre">(d,)</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.Fixed1x1Conv">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">Fixed1x1Conv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/fixed_transforms.html#Fixed1x1Conv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Fixed1x1Conv" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an invertible matrix M, a 1x1 convolution is performed using M as
the convolution kernel. Effectively, a matrix muplitplication along the
channel dimension is performed in each pixel.</p>
<dl class="py method">
<dt id="FrEIA.modules.Fixed1x1Conv.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">torch.Tensor</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/fixed_transforms.html#Fixed1x1Conv.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.Fixed1x1Conv.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional args in docstring of base class FrEIA.modules.InvertibleModule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – Square, invertible matrix, with which each input is multiplied. Shape <code class="docutils literal notranslate"><span class="pre">(d,</span> <span class="pre">d)</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="approximately-or-semi-invertible-transforms">
<h2>Approximately- or semi-invertible transforms<a class="headerlink" href="#approximately-or-semi-invertible-transforms" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="FrEIA.modules.InvAutoFC">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">InvAutoFC</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoFC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoFC" title="Permalink to this definition">¶</a></dt>
<dd><p>Fully connected ‘Invertible Autoencoder’-layer (see arxiv.org/pdf/1802.06869.pdf).
The weight matrix of the inverse is the tranposed weight matrix of the forward pass.
If a reconstruction loss between forward and inverse is used, the layer converges
to an invertible, orthogonal, linear transformation.</p>
<dl class="py method">
<dt id="FrEIA.modules.InvAutoFC.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoFC.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoFC.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dims_out</strong> – If None, the output dimenison equals the input dimenison.
However, becuase InvAuto is only asymptotically invertible, there is
no strict limitation to have the same number of input- and
ouput-dimensions. If dims_out is an integer instead of None,
that number of output dimensions is used.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.InvAutoConv2D">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">InvAutoConv2D</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoConv2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoConv2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolutional variant of the ‘Invertible Autoencoder’-layer
(see arxiv.org/pdf/1802.06869.pdf). The the inverse is a tranposed
convolution with the same kernel as the forward pass. If a reconstruction
loss between forward and inverse is used, the layer converges to an
invertible, orthogonal, linear transformation.</p>
<dl class="py method">
<dt id="FrEIA.modules.InvAutoConv2D.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/inv_auto_layers.html#InvAutoConv2D.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.InvAutoConv2D.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kernel_size</strong> – Spatial size of the convlution kernel.</p></li>
<li><p><strong>padding</strong> – Padding of the input. Choosing <code class="docutils literal notranslate"><span class="pre">padding</span> <span class="pre">=</span> <span class="pre">kernel_size</span> <span class="pre">//</span> <span class="pre">2</span></code> retains
the image shape between in- and output.</p></li>
<li><p><strong>dims_out</strong> – If None, the output dimenison equals the input dimenison.
However, becuase InvAuto is only asymptotically invertible, there is
no strict limitation to have the same number of input- and
ouput-dimensions. Therefore dims_out can also be a tuple of length 3:
(channels, width, height). The channels are the output channels of the
convolution. The user is responsible for making the width and height match
with the actual output, depending on kernel_size and padding.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.IResNetLayer">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">IResNetLayer</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_internal_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hutchinson_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_point_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lipschitz_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lipschitz_batchsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_norm_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/invertible_resnet.html#IResNetLayer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IResNetLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Implementation of the i-ResNet architecture as proposed in
<a class="reference external" href="https://arxiv.org/pdf/1811.00995.pdf">https://arxiv.org/pdf/1811.00995.pdf</a></p>
<dl class="py method">
<dt id="FrEIA.modules.IResNetLayer.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_internal_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hutchinson_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_point_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lipschitz_iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lipschitz_batchsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectral_norm_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/invertible_resnet.html#IResNetLayer.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IResNetLayer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:
dims_in: list of tuples specifying the shape of the inputs to this</p>
<blockquote>
<div><p>operator: <code class="docutils literal notranslate"><span class="pre">dims_in</span> <span class="pre">=</span> <span class="pre">[shape_x_0,</span> <span class="pre">shape_x_1,</span> <span class="pre">...]</span></code></p>
</div></blockquote>
<dl class="simple">
<dt>dims_c:  list of tuples specifying the shape of the conditions to</dt><dd><p>this operator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.IResNetLayer.lipschitz_correction">
<code class="sig-name descname"><span class="pre">lipschitz_correction</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/invertible_resnet.html#IResNetLayer.lipschitz_correction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.IResNetLayer.lipschitz_correction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt id="FrEIA.modules.GaussianMixtureModel">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">FrEIA.modules.</span></code><code class="sig-name descname"><span class="pre">GaussianMixtureModel</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/gaussian_mixture.html#GaussianMixtureModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GaussianMixtureModel" title="Permalink to this definition">¶</a></dt>
<dd><p>An invertible Gaussian mixture model. The weights, means, covariance
parameterization and component index must be supplied as conditional inputs
to the module and can come from an external feed-forward network, which may
be trained by backpropagating through the GMM. Weights should first be
normalized via GaussianMixtureModel.normalize_weights(w) and component
indices can be sampled via GaussianMixtureModel.pick_mixture_component(w).
If component indices are specified, the model reduces to that Gaussian
mixture component and maps between data x and standard normal latent
variable z. Components can also be chosen consistently at random, by
supplying an integer random seed instead of indices. If a None value is
supplied instead of indices, the model maps between K data points x and K
latent codes z simultaneously, where K is the number of mixture components.
Mathematical derivations are found in the technical report “Training Mixture
Density Networks with full covariance matrices” on arXiv.</p>
<dl class="py method">
<dt id="FrEIA.modules.GaussianMixtureModel.__init__">
<code class="sig-name descname"><span class="pre">__init__</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dims_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims_c</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/gaussian_mixture.html#GaussianMixtureModel.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GaussianMixtureModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:
dims_in: list of tuples specifying the shape of the inputs to this</p>
<blockquote>
<div><p>operator: <code class="docutils literal notranslate"><span class="pre">dims_in</span> <span class="pre">=</span> <span class="pre">[shape_x_0,</span> <span class="pre">shape_x_1,</span> <span class="pre">...]</span></code></p>
</div></blockquote>
<dl class="simple">
<dt>dims_c:  list of tuples specifying the shape of the conditions to</dt><dd><p>this operator.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.GaussianMixtureModel.nll_loss">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">nll_loss</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_jacobian</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/gaussian_mixture.html#GaussianMixtureModel.nll_loss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GaussianMixtureModel.nll_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Negative log-likelihood loss for training a Mixture Density Network.</p>
<dl class="simple">
<dt>w:              Mixture component weights, must be positive and sum to</dt><dd><p>one. Tensor must be of size [batch_size, n_components].</p>
</dd>
<dt>z:              Latent codes for all mixture components. Tensor must be</dt><dd><p>of size [batch, n_components, n_dims].</p>
</dd>
<dt>log_jacobian:   Jacobian log-determinants for each precision matrix.</dt><dd><p>Tensor size must be [batch_size, n_components].</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.GaussianMixtureModel.nll_upper_bound">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">nll_upper_bound</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_jacobian</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/gaussian_mixture.html#GaussianMixtureModel.nll_upper_bound"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GaussianMixtureModel.nll_upper_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerically more stable upper bound of the negative log-likelihood
loss for training a Mixture Density Network.</p>
<dl class="simple">
<dt>w:              Mixture component weights, must be positive and sum to</dt><dd><p>one. Tensor must be of size [batch_size, n_components].</p>
</dd>
<dt>z:              Latent codes for all mixture components. Tensor must be</dt><dd><p>of size [batch, n_components, n_dims].</p>
</dd>
<dt>log_jacobian:   Jacobian log-determinants for each precision matrix.</dt><dd><p>Tensor size must be [batch_size, n_components].</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.GaussianMixtureModel.normalize_weights">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">normalize_weights</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/gaussian_mixture.html#GaussianMixtureModel.normalize_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GaussianMixtureModel.normalize_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply softmax to ensure component weights are positive and sum to
one. Works on batches of component weights.</p>
<dl class="simple">
<dt>w:  Unnormalized weights for Gaussian mixture components, must be of</dt><dd><p>size [batch_size, n_components]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="FrEIA.modules.GaussianMixtureModel.pick_mixture_component">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">pick_mixture_component</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/FrEIA/modules/gaussian_mixture.html#GaussianMixtureModel.pick_mixture_component"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#FrEIA.modules.GaussianMixtureModel.pick_mixture_component" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly choose mixture component indices with probability given by
the component weights w. Works on batches of component weights.</p>
<p>w:      Weights of the mixture components, must be positive and sum to one
seed:   Optional RNG seed for consistent decisions</p>
</dd></dl>

</dd></dl>

</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="FrEIA.framework.html" title="previous page">FrEIA.framework package</a>

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="_static/js/index.d3f166471bb80abb5163.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2021, VLL-HD.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>